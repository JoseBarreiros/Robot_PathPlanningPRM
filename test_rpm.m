%% Version 1.0
%% Implementation of Robot Path Planning using Probabilistic Roadmap Method with Randomized Bridge Builder as described in [Hsu et al., 2013]
%% Created by Jose Barreiros, PhD student, Systems Engineering, Cornell University. 

delete(findall(0,'Type','figure')) %clean figures 

% Import Image

filepath = 'map_hw1_b.png';

image = imread(filepath);

% Convert to grayscale and then black and white image based on arbitrary threshold

grayimage = rgb2gray(image);

bw= grayimage < 0.5;


% Use black and white image as matrix input for binary occupancy grid

map = robotics.BinaryOccupancyGrid(bw,1); %resolution 1.181 for scaling from 0-1km 

show(map)

hold;

%Define start and end location of the robot. 

startLocation = [50 750]; 

endLocation = [950 250];

%Clean variables.

X=[];

G=[];

Gn=[];

Gb=[];

X_p=[];

l_test=[];

N=50; %number of milestones we want to generate. N=w*Nb+(1-w)*Nn

w=0.6; %weight of numeber of RBB (Bridge) milestones vs Uniform distrobuted milestones. 

c=0;

d=0;

i=0;

%Define Number of milestones Nb: bridge and Nn: uniform

Nb=int16(w*N); %number of milestones generated usign RBB bridge PDF

Nn=N-Nb; %Number of milestones using uniform distribution

tic;

while i<=N

    %pick X untiformely at random  

    X=[randi(size(bw,1)) randi(size(bw,2))]; %X[x y]    

    %plot(X(1),X(2),'.c');  %plot the point X

    if ((bw(abs(size(bw,1)+1-X(2)),X(1))==0) && (d<Nn))   %if clearance is true

        G=cat(1,G,X);  %include node into G.  Milestone UNIFORMLY GENERATED

        plot(X(1),X(2),'*r');

        Gn=cat(1,Gn,X); %just for debugging. cointains just the Uniform generated milestones

        i=i+1; %general milestone counter

        d=d+1; %uniform random milestone counter

    else   
        if (bw(abs(size(bw,1)+1-X(2)),X(1))==1)
            
        ROM=70; %range of motion in pixels

        res=1;%resolution

        D1=1*ROM; %standard deviation for gaussian in X

        D2=1*ROM; %standard deviation for gaussian in Y

        U1=X(2); %y center of gaussian

        U2=X(1); %x center of gaussian

        Xin=(U2-2.4*ROM):res:(U2+2.4*ROM); 

        Yin=(U1-2.4*ROM):res:(U1+2.4*ROM);

        Xmat = ones(length(Yin),1)*Xin; 

        Ymat = Yin'*ones(1,length(Xin));
       
        %PDF, radial gaussian distribution

        Dist=exp(-(Ymat-U1).^2/(2*D1^2)-(Xmat-U2).^2/(2*D2^2));  

        %retrieve a number from a customized PDF Dist usign the function
        %Pinky() from Tristan Ursell (https://goo.gl/2ySv13)
        
        [t1 t2]=pinky(Xin,Yin,Dist); 
        
        %check if X_p=[t1 t2] is between 0 and maxsize of workspace.  If it
        %is not in the range, a new value is retrieved from the PDF.
       
        while ((t1<1 || t1>size(bw,1) ||t2<1 || t2>size(bw,1) )) 

           [t1 t2]=pinky(Xin,Yin,Dist);   

        end

        %Xprima: X_p=[t1 t2]
        
        X_p=[t1 t2];

        X_p=[uint16(X_p(1)) uint16(X_p(2))];

        %plot(X_p(1),X_p(2),'sm');  %plot the point from PDF

        if bw(abs(size(bw,1)+1-X_p(2)),X_p(1))==1   % if clearance(X prima) is false 

            %plot(X_p(1),X_p(2),'sc');  %plot the point in cyan from PDF if it is in a non-occupied zone

            q=[(X(1)+X_p(1))/2 (X(2)+X_p(2))/2]; %calculate the midpoint

            q=uint16(q);

            %plot(q(1),q(2),'oc'); %plot the midpoint

            if bw(abs(size(bw,1)+1-q(2)),q(1))==0  % if clearance(q) is true 

                G=cat(1,G,q);  %add edge to G

                Gb=cat(1,Gb,q); %just for debugging. cointains just the Bridge generated milestones

                plot(q(1),q(2),'*g');

                i=i+1;

                c=c+1; %counter for milestones generated by bridge method.

            end

        end

        end
    end  

end

toc %shows the computation time for generating the milestones.

%A connectivity graph is generated usign K-neareast neighboors. 

knn=8; %number of nearest neighbors
adj=zeros(size(G,1)+2); %initialize adjacency matry
coord=[]; %initialize coordinates matrix
num_points = 20;  %number of checked points
for k=1:size(G,1)

    X=G(k,:);

    NN=knnsearch(G,X,'k',knn);

    q=X;
    coord=cat(1,coord,[q(1) q(2)]);
    for j=1:size(NN,2)

        if isequal(q,G(NN(j),:))==0
             
             %connect (q,x)
             
             a=[q(1) G(NN(j),1)];

             b=[q(2) G(NN(j),2)];
             
             plot(a,b,'g-'); %plot all the edges regardless they intersect an occupied region or not. 
            
             %check if the edge intersect with an occupied region. if false,
             %the edge is discarded
             for i=1:num_points 
                 point_x=(a(1)*i+a(2)*(num_points-i+1))/(num_points+1);
                 point_y=(b(1)*i+b(2)*(num_points-i+1))/(num_points+1);
                 l_test(i)=bw(abs(size(bw,1)+1-point_y),point_x);
             end
             
             if ismember(1, l_test(:))==0
                plot(a,b,'r-');
                adj(k,NN(j))=1;
             end             
        end
    end
end

 
%Plot start and end location with a square marker.
plot([startLocation(:,1) endLocation(:,1)],[startLocation(:,2) endLocation(:,2)],'bs');  %include start and end point. 

%connect the start and end point to the other nodes using K-nn.

loc=cat(1, startLocation, endLocation);

knn=5;

for k=1:size(loc,1)

    X=loc(k,:);

    NN=knnsearch(G,X,'k',knn);

    q=X;
    
    coord=cat(1,coord,[q(1) q(2)]);
    
    for j=1:size(NN,2)

        if isequal(q,G(NN(j),:))==0

            %connect (q,x)

            a=[q(1) G(NN(j),1)];

            b=[q(2) G(NN(j),2)];

            %plot(a,b,'g-'); for debugging.  shows the edges from q to NN(i)
            
            %check if the edge intersect with an occupied region
            for i=1:num_points 
                 point_x=(a(1)*i+a(2)*(num_points-i+1))/(num_points+1);
                 point_y=(b(1)*i+b(2)*(num_points-i+1))/(num_points+1);
                 l_test(i)=bw(abs(size(bw,1)+1-point_y),point_x);
            end
             
            if ismember(1, l_test(:))==0
                plot(a,b,'r-');
                adj(size(G,1)+k,NN(j))=1;
            end
        end
    end
end

%gplot(adj,coord,'-*c'); %for debugging. is the adjacency matrix representing the whole connectivity graph?

%A simmetric adjacency matrix Q is created to generate a graph GR
Q=transpose(adj)+adj; 

Q(Q>0)=1;

GR=graph(Q);

plot(GR, 'XData', coord(:,1), 'YData', coord(:,2),'LineWidth',2, 'EdgeColor',[1,0.7,0.9]); %number the nodes 

%find any path. the path is not necesarry the shortest because a weighted adjacency matrix was not used. 

P = shortestpath(GR,size(G,1)+1,size(G,1)+2);  

%Plot the path found with a black line. 

for i=1:(size(P,2)-1)
    P_coor=cat(1,[coord(P(i),1) coord(P(i),2)], [coord(P(i+1),1) coord(P(i+1),2)]);
    plot(P_coor(:,1),P_coor(:,2),'-xk','LineWidth',3);
end

toc %Print the computation time for the whole algorithm.

